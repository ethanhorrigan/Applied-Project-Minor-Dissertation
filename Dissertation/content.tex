%!TEX root = project.tex

\chapter*{About this project}
\paragraph{Abstract}

This project aims to offer a platform for players to create, manage and compete in competitive online matches. The system is a web application where a user can interact with to create and manage matches.\newline The demand for this application is due to how inconvenient it is for an individual to manage custom matches, determining which player goes on what team is time-consuming and very inefficient. This application will automate the process of deciding which player goes on which team through matchmaking. A point system and leaderboard are also provided to produce a competitive environment. How players gain points depends on the outcome of a match and the skill level of their opponents. Users will be able to create an account and log in, allowing them to use the system by viewing and joining public matches or creating their own match for others to join. I hope to develop a cohesive and robust system with a fluent user interface that is aimed towards people who enjoy a competitive setting and want an extra layer to their gaming experience.
\paragraph{Authors}
Ethan Horrrigan


\chapter{Introduction}
Competitive online gaming has seen a significant increase in popularity in recent times. The estimated global esports audience was estimated at 335 million people in 2017 generating a revenue of more than \$900M with an estimated growth of over \$1600M in 2021.~\cite{sjoblom2019esports} Yuri Seo and Sang-Uk Jung ~\cite{seo2016beyond} outlined why people play or spectate competitive games. The main factors include entertainment and gaining a better understanding of a game. \newline Whether spectating or participating, competitive games can consume a large portion of our free time. \newline Organising matches need some form of administration to ensure rules are upheld. Issues occur when an individual is responsible for managing these games, for example, if a match has a fixed schedule but the person responsible for managing the game is unavailable, then the tournament game is postponed. Administrators are also required to make sure that teams are is fair which is very time-consuming and unpredictable. \newline This application will automate the process of matchmaking teams which is a tedious task for an individual and offer an environment for people to compete which adds to the competitive experience.
\newpage
In order to develop this system, I needed to connect various technologies with each other and allow communication between them. I used Angular as the front-end for the application, where I could design the user interface and communicate with the back-end server to display information. I used Flask for the server and API (Application Programming Interface) this controlled how the data was transferred between the database and the web application.
The features included in the web application are a registration system, login system, leaderboards, match creation, matches page and match display and then the server-side of the application was responsible for the matchmaking and point system algorithms. 
 
I went with an iterative development approach for this application, I met with my supervisor to discuss what had been implemented in the project on a weekly basis and discussed what I will implement in the following week. This allowed me to see significant progress each week on the project.

\chapter{Summary}
\paragraph{Context:} here I explain how to the idea for the project came about, I highlight the reasons why this application was made and its core uses.
\paragraph{Methodolgy:} the methodolgy section contains how I went about developing the project, an overview of the technologies used and design choices.
\paragraph{Technology Review:} here I explain how the various technologies were implemented in the project. This section contains working examples of algorithms and features. I explain how I developed, tested and deployed this project.
\paragraph{System Design:} I show how the overall system architecture is designed and implemented. I divide the architecture into individual sections and explain the relationships between databases, platforms and deployment services.
\paragraph{System Evaluation:} I discuss how the overall system works, how I tested the system for performance, the outcome of the project and the limitations that I encountered throughout development.
\paragraph{Conclusion:} I summarise the project and evaluation.

\newpage
\subsection{Github}
https://github.com/ethanhorrigan/LOYO
\paragraph{The Readme}
\begin{itemize}
	\item Contains software architecture.


	\item Features of the project


	\item How to Build, test and deploy the project.


	\item Change log: Which contains any changes or findings I encountered throughout the project.


	\item Helpful Links
\end{itemize}
\paragraph{Issues}
\begin{itemize}
	\item I used the Issues section for project management, I created new issues depending on a feature that needed to be implemented, when that feature was finished, I would close that issues.
\end{itemize}
\chapter{Context}
\begin{itemize}
	\item This project aims to create a platform for people to manage and compete in online custom games.
	\item The core objectives are to develop a web application for people to create and find custom games and to handle handle matchmaking for these games.
\end{itemize}

\section{Competitive Gaming}
Competitive gaming often referred to as esports, which can be defined as \cite{sjoblom2019esports} “a form of sports where the primary aspects of the sport are facilitated by electronic systems; the input of players and teams, as well as the output of the esports system, are mediated by human-computer interfaces”. This can be compared to 'traditional' sports where players compete amongst each other in a competitive environment. Like sports has its types (Football, Rugby etc..), games have its genres (e.g. First Person Shooter, MOBA, Strategy etc..).
\newline
This project will focus on providing a platform for players to manage competitive matches for the popular Multiplayer Online Battle Arena (MOBA), League of Legends.
\newline
Within the game, players have different game modes which they can play
(Draft Mode and Ranked Mode). Players can receive a rank when playing in ranked mode meaning players are matched up against opponents with similar skill levels. When searching for a game, players join a queue and the system tries to create a lobby of 10 random players of similar skill levels. Custom lobbies can also be created allowing people to form a lobby of players where players ranks are inconsequential. This allows players to have complete control over the lobby (who goes onto what team). My application will manage these custom games through matchmaking instead of people deciding on who goes where which can be a nuisance and inefficient.


\section{Skill-Based Matchmaking}
The fundamental purpose of skill-based matchmaking is that a game is enjoyable for all parties. \cite{graepel2006ranking} If the participating teams have a fair chance of winning, then the match is considered to be fair, being paired against an opponent with more or less skill can ruin the experience. \cite{alman2017theoretical} To decide whether a game is balanced, we need to measure the skill of a team. We can simply add the skills of the team members to achieve this. In traditional sports like football, teams are awarded points depending on the outcome of the game. Typically, these points are increased based on a constant value, if a team wins a football match, they gain 3 points. This system reflects on the team's overall performance. Whereas in online games, they take a different approach. \cite{pelanek2016applications} The Elo rating system was originally developed for rating chess players, now it is commonly used for ranking players in many online games. Players can quickly find his/her ranking in a game using this system. when updating a players rating, it does not increase at a constant rate, the value at which it increases depends on the skill level of its opponent.

\section{Web Application}
Based off of the two sections above, I aim to develop a web application for users to manage custom matches and bypass the time-consuming process of managing custom matches. I wanted to explore new technologies and concepts that I was not familiar with. I also wanted to develop something I'm interested in. Many ideas and concepts were discussed with my supervisor when trying to figure out what to develop. I ended up settling with this idea, as it felt like something I could incorporate multiple technologies and unfamiliar concepts with. Initially, I had very little knowledge of how rating systems and matchmaking worked. I will discuss how I studied and implemented these concepts into my project in the technology review section. Once I had a clear idea on what I wanted to develop, I began studying various frameworks, platforms and technologies that would be appropriate to use throughout the project. Since I wanted this to be a web application, I could narrow down the frameworks I wanted to use. The main options that stood out to me were Angular, React or Vue. I opted for Angular since this framework came packed with features, the documentation was easy to follow and the internet had a lot of resources for learning this framework.


\chapter{Methodology}
\section{Development Methodology}
Project meetings were established at the beginning of development, Initial meetings consisted of brainstorming and considering project ideas. During this period, I conducted research on various technologies that could possibly be used throughout the project. I began development once the project was defined and understood what technologies were suitable for use throughout. Every week I would meet with my supervisor and discuss what has been implemented in the past week and what I will work on for the upcoming week. I took an iterative approach in the development of this project so I could see significant developments in the project.
\section{Testing}
I opted to use System Testing
I opted to use System Testing as the main type of testing for the project as this suited my workflow. I wanted to implement the functionality of client-side elements before testing. Unit tests were carried out near completion of development on individual components for both server-side and client-side. Jasmine and Karma was the framework used to test the functionality of web components.

TALK ABOUT SELENIUM
\begin{center}    
	\includegraphics[width=8cm,height=3.3cm,keepaspectratio]{img/Jasmine_and_Karma.png}
\end{center}
Python’s Unittest was used to test server-sided functions ensuring that both HTTP Requests and the Matchmaking algorithm operated as expected.
\begin{center}    
	\includegraphics[width=8cm,height=3.3cm,keepaspectratio]{img/Unittest.png}
\end{center}
End to end testing (e2e) was used to test the interactions and relationships between the backend and the presentation layer of the application. E2e testing was a great way to ensure that the components of the application worked together cohesively and also the application functioned correctly at a high-level overview. I concluded that unit tests were not sufficient enough, as unit tests only tested isolated elements of my project. I needed to test how the application's components operated as a combination. E2e testing was the best way to accomplish this.
Test cases were generated by scenarios in the following ways:~\cite{bai2001distributed}
\begin{itemize}
	\item (1) Identify the input data that meet the conditions associated with the component based on different testing techniques (e.g. unit tests).
	\item (2) Determine the expected results from input data. 
\end{itemize}
The main way I generated test cases was based on application usage, e.g., one component can be affected by several conditions, and each condition can be satisfied by multiple data. For example, the registration element may have input data such as username, summoner name and password. Therefore, the conditions for this test case include
\begin{itemize}
	\item 1) Valid username; 
	\item 2) Valid summoner name; 
	\item 3) Valid password;
\end{itemize}
The first test case satisfied these inputs and then the second test case took the exact input from the first scenario proving that duplicate usernames cannot be inserted into the database.

\section{Source Control}
GitHub was used for source control and project management. Initially, I was using Trello for task management but this quickly became complicated to associate updates with unfinished tasks of the project. Therefore I changed the projects task management to GitHub’s Issues section. I posted issues for any viable element that needed to be implemented into the project and when one of these elements were complete I would close the corresponding issue on GitHub. Each issue was categorized with tags depending on the type. These tags include:
\begin{itemize}
	\item To-do: Tasks that have yet to be implemented.
	\item Tests: Types of tests that have been or need to be carried out.
	\item Bugs: Issues or bugs that occurred throughout the project and how they were solved.
	\item In progress: In progress are tasks that are currently being implemented.
	\item Completed: Finished tasks.
	\item Enhancement: When a completed part of the project has been upgraded, changed or removed.
\end{itemize}
This method of task management proved to be a lot more manageable compared to my previous method of using Trello. I could easily compare my current tasks to my commits on GitHub. Anytime I had implemented a significant change or addition to my project, I would perform commit it to through git and push the change.

\section{Technologies Selection Criteria}
The primary development environment used throughout the project was Visual Studio Code, The main reasons why I chose this environment is because it supports debugging, Git control, syntax highlighting, intelligent code completion and for its customisability. Both Frontend and backend of the project were developed in this environment.
I used Angular which is an open-source web application framework led by the Angular Team at Google. The reasoning behind choosing Angular is because I wanted the project to be a web application as compared to a hybrid application, Angular seemed to be the most viable framework for this application.
When researching options for the database server, the two main options were python and flask or using MEAN stack (Mongo, Express.js, Angular and Node). I wanted the database to be a relational instead of using a NoSQL database, so a NoSQL database did not suit. I also wanted to use a technology that I'm not familiar with. These factors
\par
\begin{itemize}
	\item Agile / incremental and iterative approach to development. Planning, meetings.
	\item What about validation and testing? Junit or some other framework.
	\item If team based, did you use GitHub during the development process.
	\item Selection criteria for algorithms, languages, platforms and technolo-gies.
\end{itemize}
Check out the nice graphs in Figure \ref{tikz:graphs}, and the nice diagram in Figure \ref{tikz:mydiagram}.

\begin{figure}
	\centering
	\begin{tikzpicture}
	\begin{scope}[every node/.style={circle,thick,draw}]
	\node (a) at (0,2) {a};
	\node (b) at (2,2) {b};
	\node (c) at (2,0) {c};
	\node (d) at (0,0) {d};
	\end{scope}
	\begin{scope}[every edge/.style={draw=black,thick}]
	\path (a) edge (b);
	\path (b) edge (c);
	\path (b) edge (d);
	\path (c) edge (d);
	\end{scope}
	\node () at (1,-1) {$G_1$};
	\end{tikzpicture}
	\hspace{1.5cm}
	\begin{tikzpicture}
	\begin{scope}[every node/.style={circle,thick,draw}]
	\node (1) at (0,2) {a};
	\node (2) at (2,2) {b};
	\node (3) at (2,0) {c};
	\node (4) at (0,0) {d};
	\end{scope}
	\begin{scope}[every edge/.style={draw=black,thick}]
	\path (1) edge (2);
	\path (1) edge (3);
	\path (1) edge (4);
	\path (3) edge (4);
	\end{scope}
	\node () at (1,-1) {$G_2$};
	\end{tikzpicture}
	\caption{Nice pictures}
	\label{tikz:graphs}
\end{figure}


\begin{figure}
	\centering
	\begin{tikzpicture}[node distance=6cm]
	\node (a) [rect] {Github};
	\node (b) [rect, below of=a] {Server (Flask)};
	\node (c) [oval, right of=b] {Client (Angular)};
	\draw [line] (a) -- (c);
	\draw [line] (b) -- (c);
	\end{tikzpicture}
	\caption{Nice pictures}
	\label{tikz:graphs}
\end{figure}


\chapter{Technology Review}
\section{Angular}
Angular is an open-source web application framework led by the Angular Team at Google. It is often used for building Single Page Applications (SPA). What is a Single Page Application? In a web application, when you navigate to a different page, the entire page is reloaded, in a SPA, only the view of the content requested is reloaded. SPA provides a fluid experience for the user. A good example of a Single Page Application is Twitter. Since this application is a SPA, navigating between pages was smooth. A constant array of Routes is declared for every component.
\begin{minted}{typescript}
const routes: Routes = [
{ path: 'mypath', component: MyComponent}
{ path: 'mypath2', component: MyComponentTwo}
{ path: 'mypath3', component: MyComponentThree}
];
\end{minted}

\subsection{Why Angular?}

\begin{itemize}
	\item Components
\end{itemize}
Angular allows you to create components that provide functionality, styling and views.

\begin{itemize}
	\item Dynamic Routes
\end{itemize}
I could create unique URLs through Angulars ActivatedRoutes feature. I used this for viewing users profiles and particular match details. The URL parameters could also be accessed.
\newpage Example Button to view a match.
\begin{minted}{typescript}
//Typescript
{ path: 'match/:matchId', component: ViewMatchComponent},
\end{minted}
\begin{minted}{html}
 <!-- HTML -->
<a href="match/{{game.match_uuid}}" class="btn btn-primary">Join</a></li>
\end{minted}

\begin{itemize}
	\item Data Binding
\end{itemize}
Allows accessing of data from Typescript code to the html page view. This eliminates the process of implementing data binding myself.
Example:
\begin{minted}{typescript}
// TypeScript String Variable
myString: string = "Hello, World";

// Data Binding on the HTML Page
{{myString}}
\end{minted}

\begin{itemize}
	\item Testing
\end{itemize}
Angular includes testing frameworks (Jasmine, Karma and Protractor) for e2e testing and unit testing. When creating a new component, A template spec file is also created where test cases for each component can be easily written.

\section{SQLite}
SQLite is an open-source relational database. I used SQLite in the development of the project so I could audition how data was structured for the entire application. Each table went through iterations of changes until I was satisfied with the database schema. SQLite database is stored as a file locally \cite{newman2004sqlite} instead of running as a stand-alone process.
This made it easier to develop a prototype database and understand how data will be interpreted when deploying.
When I finally developed a functioning database I converted to a PostgreSQL production database. This was a smooth transition as both databases were relational. This meant queries didn't change and only how the database connected to the server and had to be changed.

\newpage
\begin{itemize}
	\item Connection to SQLite Database:
\end{itemize}

 \begin{minted}{python}
db_connect = create_engine('sqlite:///dev_database.db')
\end{minted}

\begin{itemize}
	\item Connection to PostgreSQL Database:
\end{itemize}

\begin{minted}{python}
connection = psycopg2.connect(user=user, password=db_password, host=host, port=port, database=database)

cursor = connection.cursor(cursor_factory=RealDictCursor)
\end{minted}
\section{PostgreSQL}
PostgreSQL (Postgres) is a Relational Database Management System (RDBMS). 
\cite{postgresql1996postgresql} Postgres is known for its reliability, data integrity and extensibility. The main reason why I chose Postgres as my production database is because of its extensibility, ensuring my application is scalable for future growth. Postgres also provides concurrency meaning queries can be read in parallel allowing multiple users to use the database at the same time.
\paragraph{Tables:}Matches and Participants both contained a match id primary key, I could access match data from both tables using a match id number. These tables were used in match creation and joining.
\begin{table}[h]
	\centering
	\begin{tabular}{llllll}
		\toprule \\
		match id & match type & match name & date & outcome & admin \\
		\midrule \\
		Row 1.2  & Row 1.2    & Row 1.3    & Row 1.4 & Row 1.5 & Row 1.6\\
		\bottomrule
	\end{tabular}
	\caption{Matches table.}
	\label{table:Matches}
\end{table}
\begin{table}[h]
	\centering
	\begin{tabular}{llllll}
		\toprule \\
		match id & username & summonername \\
		\midrule \\
		Row 1.2  & Row 1.2  & Row 1.3  \\
		\bottomrule
	\end{tabular}
	\caption{Participants table.}
	\label{table:Matches}
\end{table}
\section{PgAdmin}
PgAdmin \cite{pgadmin} is a database management tool for PostgreSQL. It simplifies the creation, maintenance, and use of database objects through a user interface. I used pgAdmin for database maintenance and to get a visual representation of data that was stored in my database. I linked the local and deployment PostgreSQL database to pgAdmin making both easily accessible for development.
\section{Heroku}
Heroku \cite{heroku} is a Free Cloud Application Platform. The Flask Server and PostgreSQL Database were both deployed on Heroku. Heroku runs applications in "dynos" which are basically just virtual computers. I created a branch on GitHub specifically for Heroku, so every time I made a new commit to GitHub, Heroku would automatically build. This allowed me to develop alot more efficiently because I did not have to start up the server each time and changes to server were automatically built, deployed and ran on each git push. 
\paragraph{Setup:} to setup Heroku for my server. I had to give it a requirments file, which contains all the servers dependencies. This is so Heroku can set up an enviroment to run the server.
\begin{minted}{text}
riotwatcher==2.7.1
Flask_Cors==3.0.8
Flask_RESTful==0.3.7
psycopg2==2.8.4
SQLAlchemy==1.3.12
numpy==1.17.3
Flask==1.1.1
python_bcrypt==0.3.2
\end{minted}
A Procfile is also made, to let Heroku know how to run the server.
\begin{minted}{text}
web: gunicorn api:app
\end{minted}
\newpage
\section{Firebase}
Firebase \cite{firebase} is a web application development platform. I used Firebase primarly for its Cloud Hosting \cite{peteva2017cloud}. Firebase provided resources for me to deploy and manage my front-end application remotely in a cloud infrastructure. This provided access for public and private end-users.
\paragraph{Setup:}
First, I created a Firebase account and a Firebase App.
I then built my front-end application into one distribution folder (/dist)
\begin{minted}{bash}
ng build --prod --aot
\end{minted}
After building the project, I initialised the Firebase app.
Selecting hosting as the feature setup.
\begin{minted}{bash}
firebase init
\end{minted}
Once the project was finish initialising, I deployed the app.
\begin{minted}{bash}
firebase deploy
\end{minted}
I could then navigate to the deployment url, to view my deployed application.
\section{Flask}
Flask is a web framework written in Python. I used Flask to develop the projects API. The projects databases and Riot Games API were connected to the flask server. This basically provided communication via CRUD operations between the projects front-end and back-end.
\paragraph{Setup}
\begin{minted}{python}
from flask import Flask, request, jsonify
app = Flask(__name__)
\end{minted}

Example of a GET request to Riot Games API to retrieve players id.
\begin{minted}{python}
def get_account_id(self):
player_details = watcher.summoner.by_name(my_region, self)
return player_details['accountId']
\end{minted}
\newpage
Working example of a GET request to retrieve match details.
\begin{minted}{python}
class GetMatch(Resource):
def get (self, _match_uuid):
cursor = connection.cursor()
query = ("Select match_uuid, match_name, match_type, date, time, admin, outcome from matches WHERE match_uuid =%s")
query_param = [_match_uuid]
 cursor.execute(query, query_param)
columns = [desc[0] for desc in cursor.description]
result = {'games': [dict(zip(columns, row)) for row in cursor.fetchall()]}
return result
\end{minted}


\section{RiotWatcher}
RiotWatcher is a Python wrapper for Riot Games API, RiotWatcher supports a simple rate limiter. This \cite{dealcisco} rate limiter will try to stop you from making too many requests to Riot Games API. I used RiotWatcher to access players in-game data and then store relevant data in my database to be used throughout the project. Here is a working example of retrieving a players ID number and verify if the player exists in Riot Games database.
\begin{minted}{python}
from riotwatcher import RiotWatcher, ApiError

watcher = RiotWatcher(<api-key>)

def get_player_details(self):
	try:
		response = watcher.summoner.by_name(my_region, self)
	except ApiError as err:
		if err.response.status_code == 429:
			print('Too many requests')
	elif err.response.status_code == 404:
		response = "SUMMONER_NOT_FOUND"
	return response
\end{minted}
\newpage
\section{Postman}
Postman \cite{postman} is a platform for Application Programming Interface (API) development. I used Postman to perform CRUD operations (Create, Read, Update, Delete) on Riot Games API and the projects API. I created collections of each request so I could easily test each operation before implementing into the projects front end. When the project was deployed, I ran the same tests but used the projects deployment URL.
\section{Jasmine}
Jasmine \cite{jasmine} is a behaviour-driven development framework for testing JavaScript code. Jasmine is a set of functions that perform unit tests. You give a function and what the result should be. These unit test cases \cite{elbaum2006carving} focuses on the individual components of the project. Jasmine was mainly used to test static components, e.g. buttons, form fields, titles etc..
\paragraph{Example:} validating user input field on the registration component
\begin{minted}{typescript}
fdescribe('RegisterComponent', () => {
	let component: RegisterComponent;
	let fixture: ComponentFixture<RegisterComponent>;	
	beforeEach(async(() => {
	TestBed.configureTestingModule({
		declarations: [ RegisterComponent ],
		imports: [ RouterTestingModule, FormsModule,],
	})
	.compileComponents();
}));

it('should validate username', () => {
	const nameInput = component.registerForm.controls.username;
	
	expect(nameInput.valid).toBeFalsy();
	
	nameInput.setValue('TestName');
	expect(nameInput.valid).toBeTruthy();
});

\end{minted}
 
\section{Karma}
Karma \cite{karmatesting} is a tool which opens a web server that executes source code against test code. The results of each test against each browser are displayed via the command so I can see if the tests passed or failed. Jasmine tests are executed through Karma. Using a configuration file, I can set which testing framework (Jasmine), port, browser and plugins needed to execute Karma.
\paragraph{My Karma Config:}
\begin{minted}{javascript}
module.exports = function (config) {
	config.set({
	 basePath: '',
	 frameworks: ['jasmine', '@angular-devkit/build-angular'],
	coverageIstanbulReporter: {
	 dir: require('path').join(__dirname, './coverage/frontend'),
	 reports: ['html', 'lcovonly', 'text-summary'],
	 fixWebpackSourcePaths: true
	},
	 port: 9876,
	 autoWatch: true,
	 browsers: ['Chrome'],
	 singleRun: false,
	 restartOnFileChange: true
	});
};

\end{minted}

\section{Selenium}
Selenium is a web testing tool which uses scripts to automate tests directly within a browser \cite{holmes2006automating}. I used Selenium for user interface automation testing. Instead of manually testing the UI which is time-consuming and error-prone, I could automate manual tasks through Selenium.

\paragraph{Example:}when implementing the user authentication system, I would have to enter the user details every time I wanted to test its functionality. Using Selenium, I could automate this process by recording each step of logging in with a test set of user details, then anytime I wanted to test the login system, I would execute this script through Selenium's IDE browser extension.
\begin{center}
\includegraphics[width=10cm,height=5.3cm,keepaspectratio]{img/Selenium.png}
\end{center}
\section{The Elo System}
The Elo rating system, developed by Arpad Elo, is used for calculating relative skill levels of players in games such as chess.\cite{glickman1999rating} A rating is a number normally between 0 and 3000, this number changes depending on the outcomes of games. When a players rating is unknown, the score for a player is assumed to be:
\[ E_a = \frac{1}{1+10\frac{E_a-E_b}{400}} \] \cite{pelanek2014application} A player's change in rating is calculated by the following formula where ${S_a}$ is the result of the game (${Win = 1}$ and $Loss = 0$), $R_o$ is the old rating and $R_n$ is the new rating.
\[ R_n = R_o + K(S_a - E_a) \]


{\raggedright The size of the score change is determined by a dynamic K value. Initially, this K value is big (30 for their first 30 games) resulting in rapid changes in Elo. This is so a player can quickly find his or her correct place in the ranking system. As the number of games increases the K value is reduced to prevent dramatic changes in Elo.}\newline
\cite{glickmanrating} The value K used to take on the values 32, 24 or 16, depending on a player’s pre-event rating. K Factor can also be defined through this equation, where $N_i$ is the effective number of games, and m is the number of games the player completed in the game.
\paragraph{Example} If Player $E_a$ has a rating of 1200 and Player $E_b$ has a rating of 1000 with both having a K value of 30, Player $E_a$ is expected to win. If Player $E_b$ wins, the rating for player $E_b$ will increase more compared to if $E_a$ won because its rating is higher.\vfill

\section{Gale Shapely Algorithm}
Complexity Upper Bound : $O(n^2)$

\paragraph{Pseudo Algorithm}
\begin{algorithm}[H]
	\KwData{this text}
	\KwResult{how to write algorithm with \LaTeX2e }
	initialization\;
	\While{not at end of this document}{
		read current\;
		\eIf{understand}{
			go to next section\;
			current section becomes this one\;
		}{
			go back to the beginning of current section\;
		}
	}
	\caption{How to write algorithms}
\end{algorithm}

\chapter{System Design}
Overall Project Architecture
\begin{center}    
	\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/Architecture.png}
\end{center}
\begin{itemize}
	\item In this section, I will dissect the above architecture and discuss each section and how it was designed.
\end{itemize}

\newpage
\section{API Procedures}

\paragraph{Extracting data from Riot Games API}
This part of the API was responsible for retrieving players in-game data from Riot Games API which I could then further manipulate and store within my own database.
\begin{itemize}
	\item Account ID
\end{itemize}
This was the ID number for the players account, this was used throughout most procedures to retrieve more information about the user.
\begin{itemize}
	\item Player Icon
\end{itemize}
Retrieving the player icon so I could use it for display on the web application.
\begin{itemize}
	\item Total Games
\end{itemize}
Total Games was calculated by adding the amount of wins and losses that was associated with a given account ID. I needed the total number for the rating system.
\begin{itemize}
	\item Rank
\end{itemize}
This function retrieved the players rank in league of legends.
(Iron, Bronze, Silver, Gold, Platinum, Diamond etc..) this information was needed for matchmaking.
\begin{itemize}
	\item Tier
\end{itemize}
This function retrieves the division the player is in, each rank has 4 divisons, this information was also needed for matchmaking.
\begin{itemize}
	\item Roman to Int
\end{itemize}
Since the rank division riot supplied was given in Roman Numeral format, I created a function which converted Roman Numerals to Integers which made the ranks easier to work with in the matchmaking algorithm.

\newpage
\paragraph{Password Setup} is used for setting up the users password for storage in the database. I used the python library, bcrypt for password encryption.

\begin{itemize}
	\item Create Password
\end{itemize}
This function took in the password as a parameter and returned a hashed version of the password.

\begin{itemize}
	\item Validate Password
\end{itemize}
Compared the given password with the stored hashed password and validated if it was correct or incorrect.


\paragraph{Project API} is responsible for the communication of data throughout the entire project, it consists of queries and functions for storing and accessing the data in the database.

\newpage
\section{Components}
\begin{itemize}
	\item Registration
\end{itemize}
\begin{center}    
	\includegraphics[width=\textwidth/2,height=\textheight,keepaspectratio]{img/Register.png}
\end{center}
TALK ABOUT REGISTRATION

\begin{center}    
	\includegraphics[width=\textwidth/2,height=\textheight,keepaspectratio]{img/UsernameTaken.png}
\end{center}
TALK ABOUT username taken

\begin{center}    
	\includegraphics[width=\textwidth/2,height=\textheight,keepaspectratio]{img/RequiredFields.png}
\end{center}
TALK ABOUT required fields

\newpage
\begin{itemize}
	\item User Authentication
\end{itemize}
\begin{center}    
	\includegraphics[width=\textwidth/2,height=\textheight,keepaspectratio]{img/Login.png}
\end{center}
TALK ABOUT Log in

\begin{center}    
	\includegraphics[width=\textwidth/2,height=\textheight,keepaspectratio]{img/LoggedIn.png}
\end{center}
TALK ABOUT already logged in

\begin{center}    
	\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/ViewGames.png}
\end{center}
TALK ABOUT view games

\begin{center}    
	\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/SearchGames.png}
\end{center}
TALK ABOUT search games

\begin{center}    
	\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/ViewMatch.png}
\end{center}
TALK ABOUT view match

\begin{center}    
	\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{img/Leaderboards.png}
\end{center}
TALK ABOUT leaderboards

\newpage
\section{Database Design}

\begin{itemize}
	\item User Table
\end{itemize}
The user table contained the majority of information for the user. This data was a mixture of registration details and their in-game data details.
\begin{table}[h]
	\centering
	\begin{tabular}{ll}
		\toprule
		Column         & Data Type \\
		\midrule
		user\_id       & int       \\
		summoner\_name & varchar   \\
		username       & varchar   \\
		password       & varchar   \\
		rank           & int       \\
		mmr            & int       \\
		total\_games   & int       \\
		primary\_role  & varchar   \\
		account\_id    & varchar   \\
		player\_icon   & int   \\ 
		\bottomrule  
	\end{tabular}
\caption{The user table.}
\end{table}

\begin{itemize}
	\item Participant Table
\end{itemize}
This held data for the players that joined a certain game.
\begin{table}[h]
	\centering
	\begin{tabular}{ll}
		\toprule
		Column         & Data Type \\
		\midrule
		match\_uuid    & varchar   \\
		username       & varchar   \\
		summoner\_name & varchar   \\
		player\_icon   & int       \\
		mmr            & int   \\
		\bottomrule    
	\end{tabular}
\caption{The participant table.}
\end{table}

\newpage
\begin{itemize}
	\item Rank Table
\end{itemize}
The rank table contained all ranks and their MMR equivalent which is used throughout the application and matchmaking.
\begin{table}[h]
	\centering
	\begin{tabular}{ll}
		\toprule
		Column         & Data Type \\
		\midrule
		rank   & varchar   \\
		mmr    & int    \\
		\bottomrule    
	\end{tabular}
	\caption{The rank table.}
\end{table}

\begin{itemize}
	\item Matches Table
\end{itemize}
This table contains all matches that have been created and the status of each match.
\begin{table}[h]
	\centering
	\begin{tabular}{ll}
		\toprule
		Column         & Data Type \\
		\midrule
		match\_uuid & varchar   \\
		match\_name & varchar   \\
		match\_type & varchar   \\
		date        & date      \\
		time        & varchar   \\
		outcome     & varchar   \\
		admin       & varchar   \\
		\bottomrule    
	\end{tabular}
	\caption{The matches table.}
\end{table}

\newpage
\begin{itemize}
	\item Final Match Table
\end{itemize}
When a match reaches its maximum amount of participants, all the participants for a that match are put through the matchmaking algorithm and then stored here. 
\begin{table}[h]
	\centering
	\begin{tabular}{ll}
		\toprule
		Column         & Data Type \\
		\midrule
		match\_uuid & varchar       \\
		team1       & varchar array \\
		team2       & varchar array \\
		\bottomrule    
	\end{tabular}
	\caption{The final match table.}
\end{table}

\paragraph{talk about typescript observables}
\paragraph{talk about heroku deployment}
\paragraph{talk about firebase deployment}
\paragraph{talk about workflow}
\paragraph{talk about point system}
\paragraph{talk about database design}
\paragraph{talk about web design}

\chapter{System Evaluation}
As many pages as needed.
\begin{itemize}
	\item Prove that your software is robust. How? Testing etc. 
	\item Use performance benchmarks (space and time) if algorithmic.
	\item Measure the outcomes / outputs of your system / software against the objectives from the Introduction.
	\item Highlight any limitations or opportuni-ties in your approach or technologies used.
\end{itemize}


\section{Limitations}
\subsection{Limited Data Access}
One of the main limitations of this project is not being able to gain access to data for custom games. The main aim of this project was to automate the process of managing custom matches and not being able to gain access to the outcome of these matches within Riots API, indicated that someone or something is responsible for determining the outcome of a match. to remedy this, each game has an administrator, he/she is responsible for confirming the outcome of a match, although this can raise multiple potential problems. I can not think of another way to combat this issue.
\newpage
\subsection{API Key}
The API key to access Riot Games API changed every day, this meant each day I was working on the project, I'd have to regenerate a new API key. After I created a new API key, I could not access the API immediately, I would have to wait a while before being able to access it again. The only way to get a static API key is to submit your application for review by Riot Games and hope they approve, this was also an extra limitation as they would not accept applications currently in development. Therefore, there was no way for me to receive a static API key. Although this is not a significant limitation, it's more of a minor inconvenience.
\subsection{Tournament Codes}
Riot Games can supply tournament codes, which would have given me the capabilities of creating private custom games. This would have suited the system a lot because I could then gain access to information about these games and their outcomes. To only way to receive these tournament codes, was to make the custom matches made through my system a prized event, meaning the winners of a match would receive some form of prize.
\section{Robust}

\chapter{Conclusion}
About three pages.

\begin{itemize}
	\item Briefly summarise your context and ob-jectives (a few lines).
	\item Highlight your findings from the evalua-tion section / chapter and any opportuni-ties identified.
	
	\item MY OPPORTUNITIES
	\item Possible Public API for tournament and match creation
	\item python package for the elo system
	\item python package for matchmaking
	\item Easy possibilties to scale this up by adding more game platforms
	\item possibilites for scaling by incorporating multiple regions
	
\end{itemize}

